{
    "contents" : "survfitJM.JMbayes <- function (object, newdata, type = c(\"SurvProb\", \"Density\"), \n                               idVar = \"id\", simulate = TRUE, survTimes = NULL, \n                               last.time = NULL, LeftTrunc_var = NULL, M = 200L, \n                               CI.levels = c(0.025, 0.975), \n                               log = FALSE, scale = 1.6, weight = rep(1, nrow(newdata)), \n                               init.b = NULL, seed = 1L, ...) {\n    if (!inherits(object, \"JMbayes\"))\n        stop(\"Use only with 'JMbayes' objects.\\n\")\n    if (!is.data.frame(newdata) || nrow(newdata) == 0L)\n        stop(\"'newdata' must be a data.frame with more than one rows.\\n\")\n    if (is.null(newdata[[idVar]]))\n        stop(\"'idVar' not in 'newdata.\\n'\")\n    type <- match.arg(type)\n    TT <- object$y$Time\n    if (is.null(survTimes) || !is.numeric(survTimes)) {\n        survTimes <- seq(min(TT), quantile(TT, 0.90) + 0.01, length.out = 35L)\n    }\n    if (type != \"SurvProb\") simulate <- TRUE\n    timeVar <- object$timeVar\n    df.RE <- object$y$df.RE\n    param <- object$param\n    densLong <- object$Funs$densLong\n    hasScale <- object$Funs$hasScale\n    anyLeftTrunc <- object$y$anyLeftTrunc\n    densRE <- object$Funs$densRE\n    transFun.value <- object$Funs$transFun.value\n    transFun.extra <- object$Funs$transFun.extra\n    extraForm <- object$Forms$extraForm\n    indFixed <- extraForm$indFixed\n    indRandom <- extraForm$indRandom\n    indBetas <- object$y$indBetas\n    TermsX <- object$Terms$termsYx\n    TermsZ <- object$Terms$termsYz\n    TermsX.extra <- object$Terms$termsYx.extra\n    TermsZ.extra <- object$Terms$termsYz.extra\n    mfX <- model.frame.default(TermsX, data = newdata)\n    mfZ <- model.frame.default(TermsZ, data = newdata)\n    formYx <- reformulate(attr(delete.response(TermsX), \"term.labels\"))\n    formYz <- object$Forms$formYz\n    estimateWeightFun <- object$estimateWeightFun\n    weightFun <- object$Funs$weightFun\n    max.time <- max(TT)\n    na.ind <- as.vector(attr(mfX, \"na.action\"))\n    na.ind <- if (is.null(na.ind)) {\n        rep(TRUE, nrow(newdata))\n    } else {\n        !seq_len(nrow(newdata)) %in% na.ind\n    }\n    id <- as.numeric(unclass(newdata[[idVar]]))\n    id <- id. <- match(id, unique(id))\n    id <- id[na.ind]\n    y <- model.response(mfX)\n    X <- model.matrix.default(formYx, mfX)\n    Z <- model.matrix.default(formYz, mfZ)[na.ind, , drop = FALSE]\n    TermsT <- object$Terms$termsT\n    data.id <- newdata[tapply(row.names(newdata), id, tail, n = 1L), ]\n    data.s <- data.id[rep(1:nrow(data.id), each = object$control$GQsurv.k), ]\n    idT <- data.id[[idVar]]\n    idT <- match(idT, unique(idT))\n    ids <- data.s[[idVar]]\n    ids <- match(ids, unique(ids))\n    if (type != \"SurvProb\") {\n        SurvT <- model.response(model.frame(TermsT, data.id))\n        Time <- SurvT[, 1]\n        event <- SurvT[, 2]\n    }\n    mfT <- model.frame.default(delete.response(TermsT), data = data.id)\n    formT <- if (!is.null(kk <- attr(TermsT, \"specials\")$cluster)) {\n        tt <- drop.terms(TermsT, kk - 1, keep.response = FALSE)\n        reformulate(attr(tt, \"term.labels\"))\n    } else {\n        tt <- attr(delete.response(TermsT), \"term.labels\")\n        if (length(tt)) reformulate(tt) else reformulate(\"1\")\n    }\n    W <- model.matrix.default(formT, mfT)[, -1L, drop = FALSE]\n    obs.times <- split(newdata[[timeVar]][na.ind], id)\n    last.time <- if (is.null(last.time)) {\n        tapply(newdata[[timeVar]], id., tail, n = 1L)\n    } else if (is.character(last.time) && length(last.time) == 1L) {\n        tapply(newdata[[last.time]], id., tail, n = 1L)\n    } else if (is.numeric(last.time)) {\n        rep_len(last.time, length.out = nrow(data.id))\n    } else {\n        stop(\"\\nnot appropriate value for 'last.time' argument.\")\n    }\n    times.to.pred <- if (type == \"SurvProb\") {\n        lapply(last.time, function (t) survTimes[survTimes > t])\n    } else {\n        as.list(Time)\n    }\n    TimeL <- if (!is.null(anyLeftTrunc) && anyLeftTrunc) {\n        if (is.null(LeftTrunc_var) || is.null(newdata[[LeftTrunc_var]])) {\n            warning(\"The original joint model was fitted in a data set with left-\",\n                    \"truncation and\\nargument 'LeftTrunc_var' of survfitJM() has not \", \n                    \"been specified.\\n\")\n        }\n        TimeL <- newdata[[LeftTrunc_var]]\n        tapply(TimeL, id, head, n = 1)\n    }\n    n <- length(TT)\n    n.tp <- length(last.time)\n    ncx <- ncol(X)\n    ncz <- ncol(Z)\n    ncww <- ncol(W)\n    if (ncww == 0L)\n        W <- NULL\n    lag <- object$y$lag\n    betas <- object$postMeans$betas\n    sigma <- object$postMeans$sigma\n    D <- object$postMeans$D\n    gammas <- object$postMeans$gammas\n    alphas <- object$postMeans$alphas\n    Dalphas <- object$postMeans$Dalphas\n    shapes <- object$postMeans$shapes\n    Bs.gammas <- object$postMeans$Bs.gammas\n    list.thetas <- list(betas = betas, sigma = sigma, gammas = gammas, alphas = alphas, \n                        Dalphas = Dalphas, shapes = shapes, Bs.gammas = Bs.gammas, D = D)\n    list.thetas <- list.thetas[!sapply(list.thetas, is.null)]\n    thetas <- unlist(as.relistable(list.thetas))\n    environment(log.posterior.b) <- environment(S.b) <- environment(logh.b) <- environment()\n    environment(hMats) <- environment(ModelMats) <- environment()\n    # construct model matrices to calculate the survival functions\n    obs.times.surv <- split(data.id[[timeVar]], idT)\n    survMats <- survMats.last <- vector(\"list\", n.tp)\n    for (i in seq_len(n.tp)) {\n        survMats[[i]] <- lapply(times.to.pred[[i]], ModelMats, ii = i, timeL = TimeL[i])\n        survMats.last[[i]] <- ModelMats(last.time[i], ii = i, timeL = TimeL[i])\n    }\n    if (type != \"SurvProb\")\n        hazMats <- hMats(Time)\n    # calculate the Empirical Bayes estimates and their (scaled) variance\n    modes.b <- matrix(0, n.tp, ncz)\n    invVars.b <- Vars.b <- vector(\"list\", n.tp)\n    for (i in seq_len(n.tp)) {\n        betas.new <- betas\n        sigma.new <- sigma\n        D.new <- D\n        gammas.new <- gammas\n        alphas.new <- alphas\n        Dalphas.new <- Dalphas\n        shapes.new <- shapes\n        Bs.gammas.new <- Bs.gammas\n        ff <- function (b, y, tt, mm, i) -log.posterior.b(b, y, Mats = tt, ii = i)\n        start <- if (is.null(init.b)) rep(0, ncz) else init.b[i, ]\n        opt <- try(optim(start, ff, y = y, tt = survMats.last, i = i, \n            method = \"BFGS\", hessian = TRUE), silent = TRUE)\n        if (inherits(opt, \"try-error\")) {\n            gg <- function (b, y, tt, mm, i) cd(b, ff, y = y, tt = tt, i = i)\n            opt <- optim(start, ff, gg, y = y, tt = survMats.last, \n                i = i, method = \"BFGS\", hessian = TRUE, \n                control = list(parscale = rep(0.1, ncz)))\n        } \n        modes.b[i, ] <- opt$par\n        invVars.b[[i]] <- opt$hessian/scale\n        Vars.b[[i]] <- scale * solve(opt$hessian)\n    }\n    if (!simulate) {\n        res <- vector(\"list\", n.tp)\n        for (i in seq_len(n.tp)) {\n            S.last <- S.b(last.time[i], modes.b[i, ], i, survMats.last[[i]])\n            S.pred <- numeric(length(times.to.pred[[i]]))\n            for (l in seq_along(S.pred))\n                S.pred[l] <- S.b(times.to.pred[[i]][l], modes.b[i, ], i, survMats[[i]][[l]])\n            res[[i]] <- cbind(times = times.to.pred[[i]], predSurv = weight[i] * S.pred / S.last)\n            rownames(res[[i]]) <- seq_along(S.pred) \n        }\n    } else {\n        set.seed(seed)\n        out <- vector(\"list\", M)\n        success.rate <- matrix(FALSE, M, n.tp)\n        b.old <- b.new <- modes.b\n        if (n.tp == 1)\n            dim(b.old) <- dim(b.new) <- c(1L, ncz)\n        mcmc <- object$mcmc\n        mcmc <- mcmc[names(mcmc) != \"b\"]\n        if (M > nrow(mcmc$betas)) {\n            warning(\"'M' cannot be set greater than \", nrow(mcmc$betas))\n            M <- nrow(mcmc$betas)\n            out <- vector(\"list\", M)\n            success.rate <- matrix(FALSE, M, n.tp)\n        }\n        samples <- sample(nrow(mcmc$betas), M)\n        mcmc[] <- lapply(mcmc, function (x) x[samples, , drop = FALSE])\n        proposed.b <- mapply(rmvt, mu = split(modes.b, row(modes.b)), Sigma = Vars.b, \n                             MoreArgs = list(n = M, df = 4), SIMPLIFY = FALSE)\n        proposed.b[] <- lapply(proposed.b, function (x) if (is.matrix(x)) x else rbind(x))\n        dmvt.proposed <- mapply(dmvt, x = proposed.b, mu = split(modes.b, row(modes.b)),\n                                Sigma = Vars.b, MoreArgs = list(df = 4, log = TRUE), \n                                SIMPLIFY = FALSE)\n        for (m in 1:M) {\n            # Step 1: extract parameter values\n            betas.new <- mcmc$betas[m, ]\n            if (hasScale)\n                sigma.new <- mcmc$sigma[m, ]\n            if (!is.null(W))\n                gammas.new <- mcmc$gammas[m, ]\n            if (param %in% c(\"td-value\", \"td-both\", \"shared-betasRE\", \"shared-RE\")) \n                alphas.new <- mcmc$alpha[m, ]\n            if (param %in% c(\"td-extra\", \"td-both\"))\n                Dalphas.new <- mcmc$Dalphas[m, ]\n            if (estimateWeightFun)\n                shapes.new <- mcmc$shapes[m, ]\n            D.new <- mcmc$D[m, ]; dim(D.new) <- dim(D)\n            Bs.gammas.new <- mcmc$Bs.gammas[m, ]\n            if (type != \"SurvProb\") {\n                logHaz <- logh.b(modes.b, hazMats)\n            }\n            SS <- vector(\"list\", n.tp)\n            for (i in seq_len(n.tp)) {\n                # Step 2: simulate new random effects values\n                p.b <- proposed.b[[i]][m, ]\n                dmvt.old <- dmvt(b.old[i, ], modes.b[i, ], invSigma = invVars.b[[i]], \n                                 df = 4, log = TRUE)\n                dmvt.prop <- dmvt.proposed[[i]][m]\n                a <- min(exp(log.posterior.b(p.b, y, survMats.last, ii = i) + dmvt.old - \n                        log.posterior.b(b.old[i, ], y, survMats.last, ii = i) - dmvt.prop), 1)\n                ind <- runif(1) <= a\n                success.rate[m, i] <- ind\n                if (!is.na(ind) && ind)\n                    b.new[i, ] <- p.b\n                # Step 3: compute Pr(T > t_k | T > t_{k - 1}; theta.new, b.new)\n                logS.last <- S.b(last.time[i], b.new[i, ], i, survMats.last[[i]], \n                                 log = TRUE)\n                logS.pred <- numeric(length(times.to.pred[[i]]))\n                for (l in seq_along(logS.pred))\n                    logS.pred[l] <- S.b(times.to.pred[[i]][l], b.new[i, ], i, \n                                        survMats[[i]][[l]], log = TRUE)\n                if (type != \"SurvProb\") {\n                    logS.pred <- event[i] * logHaz[i] + logS.pred\n                }\n                SS[[i]] <- weight[i] * if (log) logS.pred - logS.last else exp(logS.pred - logS.last)\n            }\n            b.old <- b.new\n            out[[m]] <- SS\n        }\n        res <- vector(\"list\", n.tp)\n        for (i in seq_len(n.tp)) {\n            rr <- sapply(out, \"[[\", i)\n            if (!is.matrix(rr))\n                rr <- rbind(rr)\n            res[[i]] <- cbind(\n                times = times.to.pred[[i]],\n                \"Mean\" = rowMeans(rr, na.rm = TRUE),\n                \"Median\" = apply(rr, 1L, median, na.rm = TRUE),\n                \"Lower\" = apply(rr, 1L, quantile, probs = CI.levels[1], na.rm = TRUE),\n                \"Upper\" = apply(rr, 1L, quantile, probs = CI.levels[2], na.rm = TRUE)\n            )\n            rownames(res[[i]]) <- as.character(seq_len(NROW(res[[i]])))\n        }\n    }\n    y <- split(y, id)\n    newdata. <- do.call(rbind, mapply(function (d, t) {\n        d. <- rbind(d, d[nrow(d), ])\n        d.[[timeVar]][nrow(d.)] <- t\n        d.\n    }, split(newdata, id.), last.time, SIMPLIFY = FALSE))\n    id. <- as.numeric(unclass(newdata.[[idVar]]))\n    id. <- match(id., unique(id.))\n    mfX. <- model.frame(delete.response(TermsX), data = newdata.)\n    mfZ. <- model.frame(TermsZ, data = newdata.)\n    X. <- model.matrix(formYx, mfX.)\n    Z. <- model.matrix(formYz, mfZ.)\n    fitted.y <- split(c(X. %*% betas) + rowSums(Z. * modes.b[id., , drop = FALSE]), id.)\n    names(res) <- names(y) <- names(last.time) <- names(obs.times) <- unique(unclass(newdata[[idVar]]))\n    res <- list(summaries = res, survTimes = survTimes, last.time = last.time, \n        obs.times = obs.times, y = y, \n        fitted.times = split(newdata.[[timeVar]], factor(newdata.[[idVar]])), \n        fitted.y = fitted.y, ry = range(object$y$y, na.rm = TRUE),\n        nameY = paste(object$Forms$formYx)[2L], modes.b = modes.b)\n    if (simulate) {\n        res$full.results <- out\n        res$success.rate <- success.rate\n    }\n    class(res) <- \"survfit.JMbayes\"\n    res\n}\n",
    "created" : 1443425351144.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1437896605",
    "id" : "5CA36D13",
    "lastKnownWriteTime" : 1443429642,
    "path" : "C:/Users/Dimitris/Documents/PackagesGitHub/JMbayes/R/survfitJM.JMbayes.R",
    "project_path" : "R/survfitJM.JMbayes.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}