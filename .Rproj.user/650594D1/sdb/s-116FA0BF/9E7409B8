{
    "contents" : "MCMCfit <- function (y, x, param, extraForm, baseHaz, estimateWeightFun, initials, priors, \n                     scales, Funs, Covs, Data, control, df.RE) {\n    # extract data longitudinal\n    performHC <- control$performHC\n    indBetas <- if (performHC) dropAttr(y$indBetas)\n    flat_indBetas <- unlist(indBetas)\n    y.long <- dropAttr(y$y)\n    X <- if (performHC) dropAttr(x$X, flat_indBetas) else dropAttr(x$X)\n    Z <- dropAttr(x$Z)\n    # extract data survival\n    Time <- dropAttr(y$Time)\n    event <- dropAttr(y$event)\n    TimeL <- dropAttr(y$TimeL)\n    W <- dropAttr(x$W)\n    notNullW <- !is.null(W)\n    Ws <- dropAttr(x$Ws)\n    W2 <- dropAttr(x$W2)\n    W2s <- dropAttr(x$W2s)\n    Xtime <- if (performHC) dropAttr(x$Xtime, flat_indBetas) else dropAttr(x$Xtime)\n    XXtime <- dropAttr(x$XXtime)\n    Ztime <- dropAttr(x$Ztime)\n    Xtime.extra <- if (performHC) dropAttr(x$Xtime.extra, flat_indBetas) else dropAttr(x$Xtime.extra)\n    Ztime.extra <- dropAttr(x$Ztime.extra)\n    Xs <- if (performHC) dropAttr(x$Xs, flat_indBetas) else dropAttr(x$Xs)\n    Zs <- dropAttr(x$Zs)\n    Xs.extra <- if (performHC) dropAttr(x$Xs.extra, flat_indBetas) else dropAttr(x$Xs.extra)\n    Zs.extra <- dropAttr(x$Zs.extra)\n    Xu <- if (performHC) dropAttr(x$Xu, flat_indBetas) else dropAttr(x$Xu)\n    Zu <- dropAttr(x$Zu)\n    # extract indices\n    n <- length(Time)\n    ns <- nrow(W2s)\n    nu <- nrow(Xu)\n    ncZ <- ncol(Z)\n    nrZ <- nrow(Z)\n    nrZtime <- nrow(Ztime)\n    nrZs <- nrow(Zs)\n    ncZ.extra <- ncol(Ztime.extra)\n    nrZtime.extra <- nrow(Ztime.extra)\n    nrZs.extra <- nrow(Zs.extra)\n    nrZu <- nrow(Zu)\n    id <- dropAttr(y$id)\n    idFast <- c(id[-length(id)] != id[-1L], TRUE)\n    id.GK <- dropAttr(y$id.GK)\n    id.GKFast <- c(id.GK[-length(id.GK)] != id.GK[-1L], TRUE)\n    iF <- dropAttr(extraForm$indFixed)\n    iR <- dropAttr(extraForm$indRandom)\n    idT <- dropAttr(y$idT)\n    lag <- y$lag\n    LongFormat <- y$LongFormat\n    anyLeftCens <- y$anyLeftCens\n    typeSurvInfCount <- y$typeSurvInf == \"counting\"\n    w <- rep(dropAttr(x$wk), n)\n    P <- dropAttr(x$P)\n    st <- c(t(dropAttr(x$st)))\n    if (estimateWeightFun) {\n        nshapes <- length(initials$shapes)\n        seq.nshapes <- seq_len(nshapes)\n        weightFun <- Funs$weightFun\n        id.GK2 <- dropAttr(y$id.GK2)\n        id.GK2Fast <- c(id.GK2[-length(id.GK2)] != id.GK2[-1L], TRUE)\n        id.GKu <- rep(id.GK, each = length(x$wk))\n        w2 <- rep(dropAttr(x$wk), ns)\n        P2 <- dropAttr(x$P2)\n        st2 <- c(t(dropAttr(x$st2)))\n        max.time <- max(Time)\n        u.idGK <- Time[id.GK] - st\n        u.idGK2 <- st[id.GK2] - st2\n    }\n    paramValue <- (param %in% c(\"td-value\", \"td-both\")) && !estimateWeightFun\n    paramExtra <- param %in% c(\"td-extra\", \"td-both\")\n    paramRE <- param %in% c(\"shared-betasRE\", \"shared-RE\")\n    paramSharedRE <- param == \"shared-RE\"\n    baseHazP <- baseHaz == \"P-splines\"\n    paramValueRE <- (paramValue || paramRE)\n    estimateAlphas <- paramValueRE || estimateWeightFun\n    notestimateWeightFun <- !estimateWeightFun\n    rescale_Bs.gammas <- control$rescale_Bs.gammas\n    robust_baseHaz <- control$robust_baseHaz\n    # extract initial values\n    init.betas <- betas <- dropAttr(initials$betas)\n    init.tau <- tau <- dropAttr(initials$tau)\n    init.b <- b <- dropAttr(initials$b)\n    if (param == \"shared-betasRE\") {\n        indBetasRE <- rep(y$indBetasRE, each = n)\n    }\n    if (performHC) {\n        betas1 <- betas[-flat_indBetas]\n        betas2 <- betas[flat_indBetas]\n        nbetas1 <- length(betas1)\n        nbetas2 <- length(betas2)\n        mean_b <- function (indBetas) {\n            sapply(indBetas, function (i) XXtime[, i, drop = FALSE] %*% betas[i])\n        }\n        b <- b + mean_b(indBetas)\n        indBetasL <- vector(\"logical\", length(betas))\n        indBetasL[flat_indBetas] <- TRUE\n        XXtimeL <- XXtime[rep(seq_len(n), each = ncZ), ]\n        indBetas_ <- lapply(indBetas, function (i) seq_len(nbetas2)[-i])\n        row.ind <- rep(seq_len(n * ncZ), rep(sapply(indBetas_, length), n))\n        col.ind <- unlist(rep(indBetas_, n))\n        XXtimeL[cbind(row.ind, col.ind)] <- 0\n        ind <- matrix(seq_len(n * ncZ), ncZ, n)\n        XXtimeL2 <- lapply(1:n, function (m) XXtimeL[ind[, m], indBetasL, drop = FALSE])\n        XXtimeL3 <- lapply(1:n, function (m) t(XXtimeL[ind[, m], indBetasL, drop = FALSE]))\n        nbetas22 <- nbetas2 * nbetas2\n        seqn <- seq_len(n)\n        diagbetas2 <- diag(nbetas2)\n        if (!is.null(iF)) {\n            iii <- vector(\"logical\", length(betas))\n            iii[iF] <- TRUE\n            iF <- which(iii[-flat_indBetas])\n        }\n    } else {\n        betas1 <- betas\n        betas2 <- numeric(ncZ)\n        nbetas1 <- length(betas1)\n        nbetas2 <- length(betas2)\n        indBetasL <- vector(\"logical\", length(betas))\n    }\n    init.invD <- invD <- dropAttr(initials$invD)\n    init.gammas <- gammas <- dropAttr(initials$gammas)\n    init.Bs.gammas <- Bs.gammas <- dropAttr(initials$Bs.gammas)\n    init.tauBs <- tauBs <- dropAttr(initials$tauBs)\n    init.deltaBs <- deltaBs <- dropAttr(initials$deltaBs)\n    init.alphas <- alphas <- dropAttr(initials$alphas)\n    init.Dalphas <- Dalphas <- dropAttr(initials$Dalphas)\n    init.shapes <- shapes <- dropAttr(initials$shapes)\n    # dimensions of parameters\n    nRE <- rep(ncZ, n)\n    ngammas <- length(gammas)\n    nBs.gammas <- length(Bs.gammas)\n    nalphas <- length(alphas)\n    nDalphas <- length(Dalphas)\n    # extract Funs\n    densLong <- Funs$densLong\n    hasScale <- Funs$hasScale\n    densRE <- Funs$densRE\n    transFun.value <- Funs$transFun.value\n    transFun.extra <- Funs$transFun.extra\n    # Data sets\n    data <- Data$data\n    data.id <- Data$data.id\n    data.s <- Data$data.s\n    data.u <- Data$data.u\n    # define priors\n    priorMean.betas1 <- priors$priorMean.betas[!indBetasL]\n    priorTau.betas1 <- priors$priorTau.betas[!indBetasL, !indBetasL]\n    log.prior.betas1 <- function (betas1) {\n        dmvnorm(betas1, priorMean.betas1, invSigma = priorTau.betas1, log = TRUE)\n    }\n    priorMean.betas2 <- priors$priorMean.betas[indBetasL]\n    priorTau.betas2 <- priors$priorTau.betas[indBetasL, indBetasL]\n    log.prior.betas2 <- function (betas2) {\n        dmvnorm(betas2, priorMean.betas2, invSigma = priorTau.betas2, log = TRUE)\n    }\n    priorA.tau <- priors$priorA.tau\n    priorB.tau <- priors$priorB.tau\n    log.prior.tau <- function (tau) {\n        dgamma(tau, priorA.tau, priorB.tau)\n    }\n    priorR.invD <- priors$priorR.invD\n    priorK.invD <- priors$priorK.invD\n    log.prior.invD <- function (invD) {\n        dwish(invD, priorR.invD, priorK.invD, log = TRUE)\n    }\n    priorMean.gammas <- priors$priorMean.gammas\n    priorTau.gammas <- priors$priorTau.gammas\n    log.prior.gammas <- function (gammas) {\n        dmvnorm(gammas, priors$priorMean.gammas, invSigma = priorTau.gammas, log = TRUE)\n    }\n    priorMean.Bs.gammas <- priors$priorMean.Bs.gammas\n    priorTau.Bs.gammas <- priors$priorTau.Bs.gammas\n    log.prior.Bs.gammas <- function (Bs.gammas) {\n        if (baseHazP)\n            priorTau.Bs.gammas <- tauBs * priorTau.Bs.gammas\n        dmvnorm(Bs.gammas, priorMean.Bs.gammas, invSigma = priorTau.Bs.gammas, log = TRUE)\n    }\n    priorA.tauBs <- priors$priorA.tauBs\n    priorB.tauBs <- priors$priorB.tauBs\n    priorA.deltaBs <- priors$priorA.deltaBs\n    priorB.deltaBs <- priors$priorB.deltaBs    \n    priorMean.alphas <- priors$priorMean.alphas\n    priorTau.alphas <- priors$priorTau.alphas\n    log.prior.alphas <- function (alphas) {\n        dmvnorm(alphas, priorMean.alphas, invSigma = priorTau.alphas, log = TRUE)\n    }\n    priorMean.Dalphas <- priors$priorMean.Dalphas\n    priorTau.Dalphas <- priors$priorTau.Dalphas\n    log.prior.Dalphas <- function (Dalphas) {\n        dmvnorm(Dalphas, priorMean.Dalphas, invSigma = priorTau.Dalphas, log = TRUE)\n    }\n    priorshape1Fun <- control$priorShapes$shape1\n    priorshape1.1 <- priors$priorshape1[1L]\n    priorshape1.2 <- priors$priorshape1[2L]\n    log.prior.shape1 <- function (shape1) {\n        priorshape1Fun(shape1, priorshape1.1, priorshape1.2, log = TRUE)\n    }\n    priorshape2Fun <- control$priorShapes$shape2\n    priorshape2.1 <- priors$priorshape2[1L]\n    priorshape2.2 <- priors$priorshape2[2L]\n    log.prior.shape2 <- function (shape2) {\n        priorshape2Fun(shape2, priorshape2.1, priorshape2.2, log = TRUE)\n    }\n    priorshape3Fun <- control$priorShapes$shape3\n    priorshape3.1 <- priors$priorshape3[1L]\n    priorshape3.2 <- priors$priorshape3[2L]\n    log.prior.shape3 <- function (shape3) {\n        priorshape3Fun(shape3, priorshape3.1, priorshape3.2, log = TRUE)\n    }\n    # define posteriors\n    logPost.betas1 <- function (betas1) {\n        Xbetas <- drop(X %*% betas1)\n        eta.y <- Xbetas + Zb\n        log.pyb <- fastSumID2(densLong(y.long, eta.y, 1/sqrt(tau), log = TRUE, data), idFast)\n        log.prior <- log.prior.betas1(betas1)\n        if (!paramRE) {\n            Mtime <- numeric(n)\n            Ms <- numeric(ns)\n            if (paramValue) {\n                Xtimebetas <- drop(Xtime %*% betas1)\n                Xsbetas <- drop(Xs %*% betas1)\n                vl <- transFun.value(Xtimebetas + Ztimeb, data.id)\n                vls <- transFun.value(Xsbetas + Zsb, data.s)\n                Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n                Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n            }\n            if (paramExtra) {\n                Xtime.extrabetas <- drop(Xtime.extra %*% betas1[iF])\n                Xs.extrabetas <- drop(Xs.extra %*% betas1[iF])\n                ex <- transFun.extra(Xtime.extrabetas + Ztime.extrab, data.id)\n                exs <- transFun.extra(Xs.extrabetas + Zs.extrab, data.s)\n                Mtime <- Mtime + if (is.matrix.ex) drop(ex %*% Dalphas) else ex * Dalphas\n                Ms <- Ms + if (is.matrix.exs) drop(exs %*% Dalphas) else exs * Dalphas\n            }\n            if (estimateWeightFun) {\n                Xsbetas <- drop(Xs %*% betas1)\n                Xubetas <- drop(Xu %*% betas1)\n                vl <- transFun.value(P * fastSumID2(wFun * (Xsbetas + Zsb), id.GKFast), data.id)\n                vls <- transFun.value(P2 * fastSumID2(wFun2 * (Xubetas + Zub), id.GK2Fast), data.s)\n                Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n                Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n            }\n            if (notNullW) {\n                if (LongFormat) {\n                    log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Wsgammas + Ms), id.GKFast)\n                } else {\n                    Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n                    log.Surv <- expWgammas * Int\n                }\n            } else {\n                log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n            }\n            log.ptb <- event * Mtime - log.Surv\n            list(log.post = sum(log.pyb, log.ptb, na.rm = TRUE) + log.prior,\n                 Xbetas = Xbetas,\n                 Xtimebetas = if (paramValue) Xtimebetas,\n                 Xsbetas = if (estimateAlphas) Xsbetas,\n                 Xtime.extrabetas = if (paramExtra) Xtime.extrabetas,\n                 Xs.extrabetas = if (paramExtra) Xs.extrabetas,\n                 Xubetas = if (estimateWeightFun) Xubetas,\n                 vl = if (estimateAlphas) vl, vls = if (estimateAlphas) vls,\n                 ex = if (paramExtra) ex, exs = if (paramExtra) exs, \n                 Ms = Ms, Mtime = Mtime, log.Surv = log.Surv, Int = Int)\n        } else {\n            if (paramSharedRE) {\n                list(log.post = sum(log.pyb, na.rm = TRUE) + log.prior, Xbetas = Xbetas)\n            }\n        }\n    }\n    logPost.betas1Fast <- function () {\n        log.pyb <- fastSumID2(densLong(y.long, eta.y, 1/sqrt(tau), log = TRUE, data), idFast)\n        log.prior <- log.prior.betas1(betas1)\n        if (!paramRE) {\n            Mtime <- numeric(n)\n            if (paramValue) {\n                Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n            }\n            if (paramExtra) {\n                Mtime <- Mtime + if (is.matrix.ex) drop(ex %*% Dalphas) else ex * Dalphas\n            }\n            if (estimateWeightFun) {\n                Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n            }\n            log.ptb <- event * Mtime - log.Surv\n            sum(log.pyb, log.ptb, na.rm = TRUE) + log.prior\n        } else {\n            if (paramSharedRE) {\n                sum(log.pyb, na.rm = TRUE) + log.prior\n            }\n        }\n    }\n    logPost.tau <- function (tau) {\n        log.pyb <- densLong(y.long, eta.y, 1/sqrt(tau), log = TRUE, data)\n        log.prior <- log.prior.tau(tau)\n        sum(log.pyb, na.rm = TRUE) + log.prior\n    }\n    logPost.RE <- function (b) {\n        Zb <- .rowSums(Z * b[id, , drop = FALSE], nrZ, ncZ)\n        eta.y <- if (nbetas1) Xbetas + Zb else Zb\n        log.pyb <- fastSumID2(densLong(y.long, eta.y, 1/sqrt(tau), log = TRUE, data), idFast)\n        mu_b <- if (performHC) mean_b(indBetas) else betas2\n        log.prior <- densRE(b, mu = mu_b, invD = invD, log = TRUE)\n        if (!paramRE) {\n            Mtime <- numeric(n)\n            Ms <- numeric(ns)\n            if (paramValue) {\n                Zsb <- .rowSums(Zs * b[id.GK, , drop = FALSE], nrZs, ncZ)\n                Ztimeb <- .rowSums(Ztime * b, nrZtime, ncZ)\n                if (nbetas1) {\n                    vl <- transFun.value(Xtimebetas + Ztimeb, data.id)\n                    vls <- transFun.value(Xsbetas + Zsb, data.s)                    \n                } else {\n                    vl <- transFun.value(Ztimeb, data.id)\n                    vls <- transFun.value(Zsb, data.s)                    \n                }\n                Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n                Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n            }\n            if (paramExtra) {\n                Ztime.extrab <- .rowSums(Ztime.extra * b[, iR, drop = FALSE], nrZtime.extra, ncZ.extra)\n                Zs.extrab <- .rowSums(Zs.extra * b[id.GK, iR, drop = FALSE], nrZs.extra, ncZ.extra)\n                if (nbetas1) {\n                    ex <- transFun.extra(Xtime.extrabetas + Ztime.extrab, data.id)\n                    exs <- transFun.extra(Xs.extrabetas + Zs.extrab, data.s)                    \n                } else {\n                    ex <- transFun.extra(Ztime.extrab, data.id)\n                    exs <- transFun.extra(Zs.extrab, data.s)\n                }\n                Mtime <- Mtime + if (is.matrix.ex) drop(ex %*% Dalphas) else ex * Dalphas\n                Ms <- Ms + if (is.matrix.exs) drop(exs %*% Dalphas) else exs * Dalphas\n            }\n            if (estimateWeightFun) {\n                Zsb <- .rowSums(Zs * b[id.GK, , drop = FALSE], nrZs, ncZ)\n                Zub <- .rowSums(Zu * b[id.GKu, , drop = FALSE], nrZu, ncZ)\n                if (nbetas1) {\n                    vl <- transFun.value(P * fastSumID2(wFun * (Xsbetas + Zsb), id.GKFast), data.id)\n                    vls <- transFun.value(P2 * fastSumID2(wFun2 * (Xubetas + Zub), id.GK2Fast), data.s)\n                } else {\n                    vl <- transFun.value(P * fastSumID2(wFun * Zsb, id.GKFast), data.id)\n                    vls <- transFun.value(P2 * fastSumID2(wFun2 * Zub, id.GK2Fast), data.s)\n                }\n                Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n                Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n            }            \n            if (notNullW) {\n                if (LongFormat) {\n                    log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Wsgammas + Ms), id.GKFast)\n                } else {\n                    Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n                    log.Surv <- expWgammas * Int\n                }\n            } else {\n                log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n            }\n            log.ptb <- event * Mtime - log.Surv\n            list(log.post = log.pyb + log.ptb + log.prior,\n                 Zb = Zb, Int = Int, Ms = Ms, eta.y = eta.y, log.Surv = log.Surv,\n                 Ztimeb = if (paramValue) Ztimeb,\n                 Zsb = if (estimateAlphas) Zsb,\n                 Ztime.extrab = if (paramExtra) Ztime.extrab,\n                 Zs.extrabetas = if (paramExtra) Zs.extrab,\n                 Zub = if (estimateWeightFun) Zub,\n                 vl = if (estimateAlphas) vl,\n                 vls = if (estimateAlphas) vls,\n                 ex = if (paramExtra) ex,\n                 exs = if (paramExtra) exs)\n        } else {\n            Mtime <- if (paramSharedRE) {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                drop((b - mu_b) %*% alphas) \n            } else {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                betas <- numeric(if (performHC) nbetas1 + nbetas2 else nbetas1)\n                if (nbetas1) betas[!indBetasL] <- betas1\n                if (performHC) betas[indBetasL] <- betas2\n                bb_ <- (b - mu_b) + betas[indBetasRE]\n                drop(bb_ %*% alphas)\n            }\n            log.Surv <- exp(Mtime) * Int\n            if (notNullW && !LongFormat)\n                log.Surv <- expWgammas * log.Surv\n            log.ptb <- event * Mtime - log.Surv\n            list(log.post = log.pyb + log.ptb + log.prior,\n                 Zb = Zb, eta.y = eta.y, log.Surv = log.Surv)\n        }\n    }\n    logPost.REFast <- function () {\n        eta.y <- if (nbetas1) Xbetas + Zb else Zb\n        log.pyb <- fastSumID2(densLong(y.long, eta.y, 1/sqrt(tau), log = TRUE, data), idFast)\n        mu_b <- if (performHC) mean_b(indBetas) else betas2\n        log.prior <- densRE(b, mu = mu_b, invD = invD, log = TRUE)\n        if (!paramRE) {\n            Mtime <- numeric(n)\n            if (paramValue) {\n                Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n            }\n            if (paramExtra) {\n                Mtime <- Mtime + if (is.matrix.ex) drop(ex %*% Dalphas) else ex * Dalphas\n            }\n            if (estimateWeightFun) {\n                Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n            }\n            log.ptb <- event * Mtime - log.Surv\n        } else {\n            Mtime <- if (paramSharedRE) {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                drop((b - mu_b) %*% alphas) \n            } else {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                betas <- numeric(if (performHC) nbetas1 + nbetas2 else nbetas1)\n                if (nbetas1) betas[!indBetasL] <- betas1\n                if (performHC) betas[indBetasL] <- betas2\n                bb_ <- (b - mu_b) + betas[indBetasRE]\n                drop(bb_ %*% alphas)\n            }\n            log.ptb <- event * Mtime - log.Surv\n        }\n        log.pyb + log.ptb + log.prior\n    }\n    logPost.invD <- function (invD) {\n        log.pb <- densRE(b, invD = invD, log = TRUE, prop = FALSE)\n        log.prior <- log.prior.invD(invD)\n        sum(log.pb, na.rm = TRUE) + log.prior\n    }\n    logPost.gammas <- function (gammas){\n        Wgammas <- drop(W %*% gammas)\n        log.Surv <- if (LongFormat) {\n            Wsgammas <- drop(Ws %*% gammas)\n            log.integrand <- if (paramRE) log.h0s + Wsgammas else log.h0s + Wsgammas + Ms\n            Int <- P * fastSumID2(w * exp(log.integrand), id.GKFast)\n            Int\n        } else {\n            exp(Wgammas) * Int\n        }\n        if (paramRE) {\n            Mtime <- if (paramSharedRE) {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                drop((b - mu_b) %*% alphas) \n            } else {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                betas <- numeric(if (performHC) nbetas1 + nbetas2 else nbetas1)\n                if (nbetas1) betas[!indBetasL] <- betas1\n                if (performHC) betas[indBetasL] <- betas2\n                bb_ <- (b - mu_b) + betas[indBetasRE]\n                drop(bb_ %*% alphas)\n            }\n            log.Surv <- exp(Mtime) * log.Surv\n        }\n        log.ptb <- event * Wgammas - log.Surv\n        log.prior <- log.prior.gammas(gammas)\n        list(log.post = sum(log.ptb, na.rm = TRUE) + log.prior, expWgammas = exp(Wgammas),\n             log.Surv = log.Surv, Int = if (LongFormat) Int, \n             Wsgammas = if (LongFormat) Wsgammas)\n    }\n    logPost.Bs.gammas <- function (Bs.gammas) {\n        if (rescale_Bs.gammas)\n            Bs.gammas <- drop(tchol_CovBs.gammas %*% Bs.gammas + init.Bs.gammas)\n        W2sBs.gammas <- drop(W2s %*% Bs.gammas)\n        log.integrand <- if (paramRE) W2sBs.gammas else W2sBs.gammas + Ms\n        if (notNullW && LongFormat) {\n            log.integrand <- log.integrand + Wsgammas\n        }\n        log.Surv <- Int <- P * fastSumID2(w * exp(log.integrand), id.GKFast) \n        if (paramRE) {\n            Mtime <- if (paramSharedRE) {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                drop((b - mu_b) %*% alphas) \n            } else {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                betas <- numeric(if (performHC) nbetas1 + nbetas2 else nbetas1)\n                if (nbetas1) betas[!indBetasL] <- betas1\n                if (performHC) betas[indBetasL] <- betas2\n                bb_ <- (b - mu_b) + betas[indBetasRE]\n                drop(bb_ %*% alphas)\n            }\n            log.Surv <- Int * exp(Mtime)\n        }\n        if (notNullW && !LongFormat) {\n            log.Surv <- expWgammas * log.Surv\n        }\n        log.ptb <- event * drop(W2 %*% Bs.gammas) - log.Surv\n        log.prior <- log.prior.Bs.gammas(Bs.gammas)\n        list(log.post = sum(log.ptb, na.rm = TRUE) + log.prior, log.h0s = W2sBs.gammas,\n             log.Surv = log.Surv, Int = Int)\n    }\n    logPost.Bs.gammasFast <- function () {\n        if (rescale_Bs.gammas)\n            Bs.gammas <- drop(tchol_CovBs.gammas %*% Bs.gammas + init.Bs.gammas)\n        log.ptb <- event * drop(W2 %*% Bs.gammas) - log.Surv\n        log.prior <- log.prior.Bs.gammas(Bs.gammas)\n        sum(log.ptb, na.rm = TRUE) + log.prior\n    }\n    ArankDiff <- priorA.tauBs + 0.5 * qr(priorTau.Bs.gammas)$rank\n    AdeltaBs <- priorA.deltaBs + priorA.tauBs\n    logPost.alphas <- function (alphas) {\n        if (!paramRE) {\n            Ms <- numeric(ns)\n            if (estimateAlphas) {\n                Mtime.alphas <- if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n                Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n            }\n            if (paramExtra) {\n                Ms <- Ms + if (is.matrix.exs) drop(exs %*% Dalphas) else exs * Dalphas\n            }\n            if (notNullW) {\n                if (LongFormat) {\n                    log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Wsgammas + Ms), id.GKFast)\n                } else {\n                    Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n                    log.Surv <- expWgammas * Int\n                }\n            } else {\n                log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n            }            \n            log.ptb <- event * Mtime.alphas - log.Surv\n            log.prior <- log.prior.alphas(alphas)\n            list(log.post = sum(log.ptb, na.rm = TRUE) + log.prior, log.Surv = log.Surv, \n                 Ms = Ms, Int = Int)\n        } else {\n            Mtime <- if (paramSharedRE) {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                drop((b - mu_b) %*% alphas) \n            } else {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                betas <- numeric(if (performHC) nbetas1 + nbetas2 else nbetas1)\n                if (nbetas1) betas[!indBetasL] <- betas1\n                if (performHC) betas[indBetasL] <- betas2\n                bb_ <- (b - mu_b) + betas[indBetasRE]\n                drop(bb_ %*% alphas)\n            }\n            log.Surv <- exp(Mtime) * Int\n            if (notNullW && !LongFormat)\n                log.Surv <- expWgammas * log.Surv\n            log.ptb <- event * Mtime - log.Surv\n            log.prior <- log.prior.alphas(alphas)\n            list(log.post = sum(log.ptb, na.rm = TRUE) + log.prior, log.Surv = log.Surv)\n        }\n    }\n    logPost.alphasFast <- function () {\n        if (!paramRE) {\n            Mtime.alphas <- if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n        } else {\n            Mtime.alphas <- if (paramSharedRE) {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                drop((b - mu_b) %*% alphas) \n            } else {\n                mu_b <- if (performHC) mean_b(indBetas) else betas2\n                betas <- numeric(if (performHC) nbetas1 + nbetas2 else nbetas1)\n                if (nbetas1) betas[!indBetasL] <- betas1\n                if (performHC) betas[indBetasL] <- betas2\n                bb_ <- (b - mu_b) + betas[indBetasRE]\n                drop(bb_ %*% alphas)\n            }\n        }\n        log.ptb <- event * Mtime.alphas - log.Surv\n        log.prior <- log.prior.alphas(alphas)\n        sum(log.ptb, na.rm = TRUE) + log.prior\n    }\n    logPost.Dalphas <- function (Dalphas) {\n        Ms <- numeric(ns)\n        if (estimateAlphas) {\n            Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n        }\n        if (paramExtra) {\n            Mtime.Dalphas <- if (is.matrix.ex) drop(ex %*% Dalphas) else ex * Dalphas\n            Ms <- Ms + if (is.matrix.exs) drop(exs %*% Dalphas) else exs * Dalphas\n        }        \n        if (notNullW) {\n            if (LongFormat) {\n                log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Wsgammas + Ms), id.GKFast)\n            } else {\n                Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n                log.Surv <- expWgammas * Int\n            }\n        } else {\n            log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n        }\n        log.ptb <- event * Mtime.Dalphas - log.Surv\n        log.prior <- log.prior.Dalphas(Dalphas)\n        list(log.post = sum(log.ptb, na.rm = TRUE) + log.prior, log.Surv = log.Surv,\n             Ms = Ms, Int = Int)\n    }\n    logPost.DalphasFast <- function () {\n        Mtime.Dalphas <- if (is.matrix.ex) drop(ex %*% Dalphas) else ex * Dalphas\n        log.ptb <- event * Mtime.Dalphas - log.Surv\n        log.prior <- log.prior.Dalphas(Dalphas)\n        sum(log.ptb, na.rm = TRUE) + log.prior\n    }\n    logPost.shape <- function (shape, which) {\n        shapes[which] <- shape\n        Ms <- numeric(ns)\n        ###\n        wFun <- w * weightFun(u.idGK, shapes, max.time)\n        wFun2 <- w2 * weightFun(u.idGK2, shapes, max.time)\n        if (nbetas1) {\n            vl <- transFun.value(P * fastSumID2(wFun * XsbetasZsb, id.GKFast), data.id)\n            vls <- transFun.value(P2 * fastSumID2(wFun2 * XubetasZub, id.GK2Fast), data.s)\n        } else {\n            vl <- transFun.value(P * fastSumID2(wFun * Zsb, id.GKFast), data.id)\n            vls <- transFun.value(P2 * fastSumID2(wFun2 * Zub, id.GK2Fast), data.s)\n        }\n        Mtime <- if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n        Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n        ###\n        if (paramExtra) {\n            Ms <- Ms + if (is.matrix.exs) drop(exs %*% Dalphas) else exs * Dalphas\n        }\n        ###\n        if (notNullW) {\n            if (LongFormat) {\n                log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Wsgammas + Ms), id.GKFast)\n            } else {\n                Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n                log.Surv <- expWgammas * Int\n            }\n        } else {\n            log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n        }\n        log.ptb <- event * Mtime - log.Surv\n        log.prior <- switch(which, \"1\" = log.prior.shape1(shape), \n                            \"2\" = log.prior.shape2(shape), \"3\" = log.prior.shape3(shape))\n        list(log.post = sum(log.ptb, na.rm = TRUE) + log.prior, log.Surv = log.Surv,\n             Ms = Ms, Int = Int, wFun = wFun, wFun2 = wFun2, vl = vl, vls = vls)\n    }\n    # define proposals\n    # betas\n    if (nbetas1) {\n        propCov.betas1 <- eigen(Covs$betas[!indBetasL, !indBetasL], symmetric = TRUE)\n        scale.betas1 <- if (!is.null(ss <- scales[[\"betas\"]])) ss else 5.66/nbetas1\n        r.betas1 <- function (n) {\n            propCov.betas1$values <- propCov.betas1$values * scale.betas1\n            rmvnorm(n, mu = NULL, Sigma = propCov.betas1)\n        }        \n    }\n    # b\n    propCov.RE <- lapply(Covs$b, eigen, symmetric = TRUE)\n    scale.RE <- if (!is.null(ss <- scales[[\"b\"]])) ss else 5.66/nRE\n    r.RE <- function (N) {\n        out <- array(0, c(dim(b), N))\n        for (i in 1:n) {\n            propCov.RE[[i]][[\"values\"]] <- propCov.RE[[i]][[\"values\"]] * scale.RE[i]\n            out[i, , ] <- rmvnorm(N, mu = NULL, Sigma = propCov.RE[[i]])\n        }\n        out\n    }\n    # invD\n    isNulldf.RE <- is.null(df.RE)\n    diagB <- diag(1, ncZ)\n    if (isNulldf.RE) {\n        K.invDn <- priorK.invD + n\n        r.invD <- function (N) {\n            drop(rWishart(N, K.invDn, R.Dbtb))\n        }\n    } else {\n        K.invDn <- (df.RE / (df.RE - 2)) * (priorK.invD + n)\n        r.invD <- function (N) {\n            drop(rWishart(N, K.invDn, invD / K.invDn))\n        }\n    }\n    # gammas\n    if (notNullW) {\n        propCov.gammas <- eigen(Covs$gammas, symmetric = TRUE)\n        scale.gammas <- if (!is.null(ss <- scales$gammas)) ss else 5.66/ngammas\n        r.gammas <- function (N) {\n            propCov.gammas$values <- propCov.gammas$values * scale.gammas\n            rmvnorm(N, mu = NULL, Sigma = propCov.gammas)\n        }\n    }\n    # Bs.gammas\n    if (rescale_Bs.gammas) {\n        tchol_CovBs.gammas <- t(chol(Covs$Bs.gammas))\n        Bs.gammas <- rep(0, nBs.gammas)\n        scale.Bs.gammas <- if (!is.null(ss <- scales$Bs.gammas)) ss else 5.66/nBs.gammas\n        r.Bs.gammas <- function (N) {\n            matrix(rnorm(N * nBs.gammas, sd = scale.Bs.gammas), N, nBs.gammas)\n        }\n    } else {\n        propCov.Bs.gammas <- eigen(Covs$Bs.gammas, symmetric = TRUE)\n        scale.Bs.gammas <- if (!is.null(ss <- scales$Bs.gammas)) ss else 5.66/nBs.gammas\n        r.Bs.gammas <- function (N) {\n            propCov.Bs.gammas$values <- propCov.Bs.gammas$values * scale.Bs.gammas\n            rmvnorm(N, mu = NULL, Sigma = propCov.Bs.gammas)\n        }\n    }\n    # alphas\n    if (estimateAlphas) {\n        propCov.alphas <- eigen(Covs$alphas, symmetric = TRUE)\n        scale.alphas <- if (!is.null(ss <- scales$alphas)) ss else 5.66/nalphas\n        r.alphas <- function (N) {\n            propCov.alphas$values <- propCov.alphas$values * scale.alphas\n            rmvnorm(N, mu = NULL, Sigma = propCov.alphas)\n        }\n    }\n    # Dalphas\n    if (paramExtra) {\n        propCov.Dalphas <- eigen(Covs$Dalphas, symmetric = TRUE)\n        scale.Dalphas <- if (!is.null(ss <- scales$Dalphas)) ss else 5.66/nDalphas\n        r.Dalphas <- function (N) {\n            propCov.Dalphas$values <- propCov.Dalphas$values * scale.Dalphas\n            rmvnorm(N, mu = NULL, Sigma = propCov.Dalphas)\n        }\n    }\n    # number of iterations\n    n.adapt <- control$n.adapt\n    n.burnin <- control$n.burnin\n    totalIter <- control$n.iter + n.adapt + n.burnin\n    n.thin <- control$n.thin\n    n.batch <- control$n.batch\n    # objects to keep results\n    resInd <- seq(n.adapt + n.burnin + 1L, totalIter, by = n.thin)\n    n.out <- length(resInd)\n    if (nbetas1)\n        res.betas1 <- matrix(0, n.out, nbetas1)\n    if (performHC)\n        res.betas2 <- matrix(0, n.out, nbetas2)\n    if (hasScale)\n        res.tau <- matrix(0, n.out, 1)\n    res.b <- array(0, c(dim(b), n.out))\n    if (performHC)\n        res.mean_b <- array(0, c(dim(b), n.out))\n    res.invD <- matrix(0, n.out, length(invD))\n    res.Bs.gammas <- matrix(0, n.out, length(Bs.gammas))\n    if (baseHazP)\n        res.tauBs <- matrix(0, n.out, 1)\n    if (notNullW)\n        res.gammas <- matrix(0, n.out, length(gammas))\n    if (estimateAlphas)\n        res.alphas <- matrix(0, n.out, length(alphas))\n    if (paramExtra)\n        res.Dalphas <- matrix(0, n.out, length(Dalphas))\n    if (estimateWeightFun)\n        res.shapes <- matrix(0, n.out, length(shapes))\n    res.logLik <- matrix(0, n.out, n)\n    # acceptance rates\n    ar.betas <- ar.invD <- ar.gammas <- ar.Bs.gammas <- ar.alphas <- ar.Dalphas <- numeric(totalIter)\n    ar.b <- matrix(0, totalIter, n)\n    # initiate all components at the starting values\n    Zb <- rowSums(Z * b[id, , drop = FALSE])\n    eta.y <- if (nbetas1) {\n        Xbetas <- drop(X %*% betas1)\n        Xbetas + Zb \n    } else Zb\n    Mtime <- numeric(n)\n    Ms <- numeric(ns)\n    if (paramValue) {\n        Ztimeb <- rowSums(Ztime * b)\n        Zsb <- rowSums(Zs * b[id.GK, , drop = FALSE])\n        if (nbetas1) {\n            Xtimebetas <- drop(Xtime %*% betas1)\n            Xsbetas <- drop(Xs %*% betas1)\n            vl <- transFun.value(Xtimebetas + Ztimeb, data.id)\n            vls <- transFun.value(Xsbetas + Zsb, data.s)\n        } else {\n            vl <- transFun.value(Ztimeb, data.id)\n            vls <- transFun.value(Zsb, data.s)\n        }\n        is.matrix.vl <- is.matrix(vl); is.matrix.vls <- is.matrix(vls)\n        Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n        Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n    }\n    if (paramExtra) {\n        Ztime.extrab <- rowSums(Ztime.extra * b[, iR, drop = FALSE])\n        Zs.extrab <- rowSums(Zs.extra * b[id.GK, iR, drop = FALSE])\n        if (nbetas1) {\n            Xtime.extrabetas <- drop(Xtime.extra %*% betas1[iF])\n            Xs.extrabetas <- drop(Xs.extra %*% betas1[iF])\n            ex <- transFun.extra(Xtime.extrabetas + Ztime.extrab, data.id)\n            exs <- transFun.extra(Xs.extrabetas + Zs.extrab, data.s)\n        } else {\n            ex <- transFun.extra(Ztime.extrab, data.id)\n            exs <- transFun.extra(Zs.extrab, data.s)\n        }\n        is.matrix.ex <- is.matrix(ex); is.matrix.exs <- is.matrix(exs)\n        Mtime <- Mtime + if (is.matrix.ex) drop(ex %*% Dalphas) else ex * Dalphas\n        Ms <- Ms + if (is.matrix.exs) drop(exs %*% Dalphas) else exs * Dalphas\n    }\n    if (estimateWeightFun) {\n        wFun <- w * weightFun(u.idGK, shapes, max.time)\n        Zsb <- rowSums(Zs * b[id.GK, , drop = FALSE])\n        wFun2 <- w2 * weightFun(u.idGK2, shapes, max.time)\n        Zub <- rowSums(Zu * b[id.GKu, , drop = FALSE])\n        if (nbetas1) {\n            Xsbetas <- drop(Xs %*% betas1)\n            Xubetas <- drop(Xu %*% betas1)\n            vl <- transFun.value(P * fastSumID2(wFun * (Xsbetas + Zsb), id.GKFast), data.id)\n            vls <- transFun.value(P2 * fastSumID2(wFun2 * (Xubetas + Zub), id.GK2Fast), data.s)\n        } else {\n            vl <- transFun.value(P * fastSumID2(wFun * Zsb, id.GKFast), data.id)\n            vls <- transFun.value(P2 * fastSumID2(wFun2 * Zub, id.GK2Fast), data.s)\n        }\n        is.matrix.vl <- is.matrix(vl); is.matrix.vls <- is.matrix(vls)\n        Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n        Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n    }\n    log.h0s <- if (rescale_Bs.gammas) {\n        drop(W2s %*% (tchol_CovBs.gammas %*% Bs.gammas + init.Bs.gammas))\n    } else drop(W2s %*% Bs.gammas)\n    log.integrand <- if (paramRE) log.h0s else log.h0s + Ms\n    if (notNullW && LongFormat) {\n        Wsgammas <- drop(Ws %*% gammas)\n        log.integrand <- log.integrand + Wsgammas\n    }\n    log.Surv <- Int <- P * fastSumID2(w * exp(log.integrand), id.GKFast) \n    if (paramRE) {\n        Mtime <- if (paramSharedRE) {\n            mu_b <- if (performHC) mean_b(indBetas) else betas2\n            drop((b - mu_b) %*% alphas) \n        } else {\n            mu_b <- if (performHC) mean_b(indBetas) else betas2\n            betas <- numeric(if (performHC) nbetas1 + nbetas2 else nbetas1)\n            if (nbetas1) betas[!indBetasL] <- betas1\n            if (performHC) betas[indBetasL] <- betas2\n            bb_ <- (b - mu_b) + betas[indBetasRE]\n            drop(bb_ %*% alphas)\n        }\n        log.Surv <- Int * exp(Mtime)\n    }\n    if (notNullW && !LongFormat) {\n        expWgammas <- exp(drop(W %*% gammas))\n        log.Surv <- expWgammas * log.Surv\n    }\n    #########################################################################################################\n    # run the MCMC\n    set.seed(control$seed)\n    batch <- 1L\n    jj <- 0L\n    batchStart <- round((n.adapt + n.burnin) / n.batch)\n    if (control$verbose) {\n        cat(\"\\n MCMC iterations:\\n\\n\")\n        pb <- txtProgressBar(0, totalIter, style = 3, char = \"+\", width = 50)\n    }\n    time <- system.time(for (i in seq_len(totalIter)) {#\n        if (i == 1L || !i %% n.batch) {\n            if (i > 1 && i <= n.adapt) {\n                ss <- seq(1L + n.batch * (batch - 1L), n.batch * batch)\n                if (nbetas1 && is.null(scales[[\"betas\"]]))\n                    scale.betas1 <- scbetasF <- adjustScaleRW(scale.betas1, mean(ar.betas[ss]), nbetas1)\n                if (is.null(scales[[\"b\"]]))\n                    scale.RE <- mapply(adjustScaleRW, scale = scale.RE, acceptRate = colMeans(ar.b[ss, ]), d = nRE)\n                if (notNullW && is.null(scales$gammas)) {\n                    scale.gammas <- scgammasF <- adjustScaleRW(scale.gammas, mean(ar.gammas[ss]), ngammas)\n                }\n                if (is.null(scales$Bs.gammas))\n                    scale.Bs.gammas <- scBs.gammasF <- adjustScaleRW(scale.Bs.gammas, mean(ar.Bs.gammas[ss]), nBs.gammas)\n                if (estimateAlphas && is.null(scales$alphas)) {\n                    scale.alphas <- scalphasF <- adjustScaleRW(scale.alphas, mean(ar.alphas[ss]), nalphas)\n                }\n                if (paramExtra && is.null(scales$Dalphas)) {\n                    scale.Dalphas <- adjustScaleRW(scale.Dalphas, mean(ar.Dalphas[ss]), nDalphas)\n                }\n                if (!isNulldf.RE) {\n                    K.invDn <- adjustKRW(K.invDn, mean(ar.invD[ss]), ncZ)\n                }\n            }\n            if (i > 1)\n                batch <- batch + 1L\n            if (nbetas1)\n                new.betas1 <- r.betas1(n.batch)\n            new.b <- r.RE(n.batch)\n            if (notNullW)\n                new.gammas <- r.gammas(n.batch)\n            new.Bs.gammas <- r.Bs.gammas(n.batch)\n            if (estimateAlphas)\n                new.alphas <- r.alphas(n.batch)\n            if (paramExtra)\n                new.Dalphas <- r.Dalphas(n.batch)\n        }\n        # batch index\n        ii <- i - n.batch * if (!i %% n.batch) i %/% n.batch - 1L else i %/% n.batch\n        # update betas1\n        if (nbetas1) {\n            lP.old.betas <- logPost.betas1Fast()\n            new.betas1[ii, ] <- new.betas1[ii, ] + betas1\n            lP.betas <- logPost.betas1(new.betas1[ii, ])\n            lP.new.betas <- lP.betas$log.post\n            lRatio.betas <- lP.new.betas - lP.old.betas\n            if (is.finite(lRatio.betas) && (lRatio.betas >= 0 || runif(1L) < exp(lRatio.betas))) {\n                ar.betas[i] <- 1\n                betas1 <- new.betas1[ii, ]\n                Xbetas <- lP.betas$Xbetas\n                eta.y <- Xbetas + Zb\n                if (!paramRE) {\n                    Xtimebetas <- lP.betas$Xtimebetas\n                    Xsbetas <- lP.betas$Xsbetas\n                    Xtime.extrabetas <- lP.betas$Xtime.extrabetas\n                    Xs.extrabetas <- lP.betas$Xs.extrabetas\n                    Xubetas <- lP.betas$Xubetas\n                    vl <- lP.betas$vl; vls <- lP.betas$vls\n                    ex <- lP.betas$ex; exs <- lP.betas$exs\n                    Mtime <- lP.betas$Mtime\n                    Ms <- lP.betas$Ms\n                    log.Surv <- lP.betas$log.Surv\n                    Int <- lP.betas$Int\n                }\n                if (param == \"shared-betasRE\")\n                    log.Surv <- lP.betas$log.Surv\n            }\n        }\n        # update tau\n        if (hasScale) {\n            tau <- slice.tau(logPost.tau, tau, step = 0.5)\n        }\n        # update RE\n        lP.old.b <- logPost.REFast() #logPost.RE(b)[[1]] \n        new.b[, , ii] <- new.b[, , ii] + b\n        lP.RE <- logPost.RE(as.matrix(new.b[, , ii]))\n        lP.new.b <- lP.RE$log.post\n        lRatio.b <- lP.new.b - lP.old.b\n        indRE <- runif(n) < pmin(exp(lRatio.b), 1)\n        if (anyNA(indRE))\n            indRE[is.na(indRE)] <- FALSE\n        indRE.GK <- indRE[id.GK]\n        indRE.id <- indRE[id]\n        ar.b[i, indRE] <- 1\n        b[indRE, ] <- new.b[indRE, , ii]\n        Zb[indRE.id] <- lP.RE$Zb[indRE.id]\n        log.Surv[indRE] <- lP.RE$log.Surv[indRE]\n        eta.y <- if (nbetas1) Xbetas + Zb else Zb\n        if (!paramRE) {\n            Ms[indRE.GK] <- lP.RE$Ms[indRE.GK]\n            if (notNullW) {\n                if (LongFormat) {\n                    log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Wsgammas + Ms), id.GKFast)\n                } else {\n                    Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n                    log.Surv <- expWgammas * Int\n                }\n            } else {\n                log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n            }\n            if (estimateAlphas) {\n                if (notestimateWeightFun)\n                    Ztimeb[indRE] <- lP.RE$Ztimeb[indRE]\n                Zsb[indRE.GK] <- lP.RE$Zsb[indRE.GK]\n                if (is.matrix.vl) {\n                    vl[indRE, ] <- lP.RE$vl[indRE, ]\n                    vls[indRE.GK, ] <- lP.RE$vls[indRE.GK, ]\n                } else {\n                    vl[indRE] <- lP.RE$vl[indRE]\n                    vls[indRE.GK] <- lP.RE$vls[indRE.GK]\n                }\n            }\n            if (paramExtra) {\n                Ztime.extrab[indRE] <- lP.RE$Ztime.extrab[indRE]\n                Zs.extrab[indRE.GK] <- lP.RE$Zs.extrab[indRE.GK]\n                if (is.matrix.ex) {\n                    ex[indRE, ] <- lP.RE$ex[indRE, ]\n                    exs[indRE.GK, ] <- lP.RE$exs[indRE.GK, ]\n                } else {\n                    ex[indRE] <- lP.RE$ex[indRE]\n                    exs[indRE.GK] <- lP.RE$exs[indRE.GK]\n                }\n            }\n            if (estimateWeightFun) {\n                indRE.GKu <- indRE[id.GKu]\n                Zub[indRE.GKu] <- lP.RE$Zub[indRE.GKu]\n            }\n        }\n        # update betas2\n        if (performHC) {\n            mat <- numeric(nbetas22); dim(mat) <- c(nbetas2, nbetas2)\n            mu <- numeric(nbetas2)\n            for (m in seqn) {\n                xxt_invD <- XXtimeL3[[m]] %*% invD\n                mat <- mat + xxt_invD %*% XXtimeL2[[m]]\n                mu <- mu + xxt_invD %*% b[m, ]\n            }\n            invV_betas2 <- mat + priorTau.betas2\n            V_betas2 <- solve.default(invV_betas2, diagbetas2)\n            mu_betas2 <- V_betas2 %*% mu\n            betas2 <- rmvnorm(1, mu_betas2, V_betas2)\n        }\n        # update invD\n        if (isNulldf.RE) {\n            bb <- if (performHC) crossprod(b - mean_b(indBetas)) else crossprod(b)\n            R.Dbtb <- solve.default(priorR.invD + bb, diagB)\n            new.invD <- r.invD(1)\n            ar.invD[i] <- 1\n            invD <- new.invD\n        } else {\n            new.invD <- r.invD(1)\n            lP.old.invD <- logPost.invD(invD)\n            lP.new.invD <- logPost.invD(new.invD)\n            lRatio.invD <- lP.new.invD + dwish(invD, invD / K.invDn, K.invDn, TRUE) -\n                lP.old.invD - dwish(new.invD, invD / K.invDn, K.invDn, TRUE)\n            if (lRatio.invD >= 0 || runif(1L) < exp(lRatio.invD)) {\n                ar.invD[i] <- 1\n                invD <- new.invD\n            }\n        }\n        # update gammas\n        if (notNullW) {\n            lP.old.gammas <- logPost.gammas(gammas)$log.post\n            new.gammas[ii, ] <- new.gammas[ii, ] + gammas\n            lP.gammas <- logPost.gammas(new.gammas[ii, ])\n            lP.new.gammas <- lP.gammas$log.post\n            lRatio.gammas <- lP.new.gammas - lP.old.gammas\n            if (is.finite(lRatio.gammas) && (lRatio.gammas >= 0 || runif(1L) < exp(lRatio.gammas))) {\n                ar.gammas[i] <- 1\n                gammas <- new.gammas[ii, ]\n                expWgammas <- lP.gammas$expWgammas\n                log.Surv <- lP.gammas$log.Surv\n                if (LongFormat) {\n                    Wsgammas <- lP.gammas$Wsgammas\n                    Int <- lP.gammas$Int\n                }\n            }\n        }\n        # update Bs.gammas\n        lP.old.Bs.gammas <- logPost.Bs.gammasFast()\n        new.Bs.gammas[ii, ] <- new.Bs.gammas[ii, ] + Bs.gammas\n        lP.Bs.gammas <- logPost.Bs.gammas(new.Bs.gammas[ii, ])\n        lP.new.Bs.gammas <- lP.Bs.gammas$log.post\n        lRatio.Bs.gammas <- lP.new.Bs.gammas - lP.old.Bs.gammas\n        if (is.finite(lRatio.Bs.gammas) && (lRatio.Bs.gammas >= 0 || runif(1L) < exp(lRatio.Bs.gammas))) {\n            ar.Bs.gammas[i] <- 1\n            Bs.gammas <- new.Bs.gammas[ii, ]\n            log.h0s <- lP.Bs.gammas$log.h0s\n            log.Surv <- lP.Bs.gammas$log.Surv\n            Int <- lP.Bs.gammas$Int\n        }\n        # update tauBs\n        if (baseHazP) {\n            Bs.gammas_s <- if (rescale_Bs.gammas) {\n                drop(tchol_CovBs.gammas %*% Bs.gammas + init.Bs.gammas)\n            } else Bs.gammas\n            if (robust_baseHaz) {\n                BB <- deltaBs * priorB.tauBs + \n                    0.5 * drop(crossprod(Bs.gammas_s, priorTau.Bs.gammas %*% Bs.gammas_s))\n                tauBs <- rgamma(1L, ArankDiff, BB)\n                deltaBs <- rgamma(1L, AdeltaBs, priorB.deltaBs + priorB.tauBs * tauBs)                \n            }\n            else {\n                BB <- priorB.tauBs + \n                    0.5 * drop(crossprod(Bs.gammas_s, priorTau.Bs.gammas %*% Bs.gammas_s))\n                tauBs <- rgamma(1L, ArankDiff, BB)                \n            }\n        }\n        # update alphas\n        if (estimateAlphas) {\n            lP.old.alphas <- logPost.alphasFast()\n            new.alphas[ii, ] <- new.alphas[ii, ] + alphas\n            lP.alphas <- logPost.alphas(new.alphas[ii, ])\n            lP.new.alphas <- lP.alphas$log.post\n            lRatio.alphas <- lP.new.alphas - lP.old.alphas\n            if (is.finite(lRatio.alphas) && (lRatio.alphas >= 0 || runif(1L) < exp(lRatio.alphas))) {\n                ar.alphas[i] <- 1\n                alphas <- new.alphas[ii, ]\n                log.Surv <- lP.alphas$log.Surv\n                if (!paramRE) {\n                    Ms <- lP.alphas$Ms\n                    Int <- lP.alphas$Int\n                }\n            }\n        }\n        # update Dalphas\n        if (paramExtra) {\n            lP.old.Dalphas <- logPost.DalphasFast()\n            new.Dalphas[ii, ] <- new.Dalphas[ii, ] + Dalphas\n            lP.Dalphas <- logPost.Dalphas(new.Dalphas[ii, ])\n            lP.new.Dalphas <- lP.Dalphas$log.post\n            lRatio.Dalphas <- lP.new.Dalphas - lP.old.Dalphas\n            if (is.finite(lRatio.Dalphas) && (lRatio.Dalphas >= 0 || runif(1L) < exp(lRatio.Dalphas))) {\n                ar.Dalphas[i] <- 1\n                Dalphas <- new.Dalphas[ii, ]\n                Ms <- lP.Dalphas$Ms\n                log.Surv <- lP.Dalphas$log.Surv\n                Int <- lP.Dalphas$Int\n            }\n        }\n        # update shapes\n        if (estimateWeightFun) {\n            if (control$verbose2)\n                cat(\"\\ni =\", i, \"\\tshapes =\", round(shapes, 3L), \n                    if (paramExtra) \"\\tDalphas =\", if (paramExtra) round(Dalphas, 3L), \n                    \"\\talphas =\", round(alphas, 3L), \"\\tbetas = \", round(betas, 3L))\n            if (nbetas1) {\n                XsbetasZsb <- Xsbetas + Zsb\n                XubetasZub <- Xubetas + Zub\n            }\n            for (shp in seq.nshapes) {\n                ss <- 1\n                slice.shp <- slice.shape(logPost.shape, shapes, step = ss, which = shp)\n                while (slice.shp$fail) {\n                    ss <- ss/10\n                    if (ss < 1e-03)\n                        break\n                    slice.shp <- slice.shape(logPost.shape, shapes, step = ss, which = shp)\n                }\n                if (!slice.shp$fail) {\n                    shapes[shp] <- slice.shp$new.shape\n                    if (shp == nshapes) {\n                        log.Surv <- slice.shp$log.Surv\n                        Ms <- slice.shp$Ms\n                        Int <- slice.shp$Int\n                        wFun <- slice.shp$wFun\n                        wFun2 <- slice.shp$wFun2\n                        vl <- slice.shp$vl\n                        vls <- slice.shp$vls                    \n                    }\n                }\n            }\n        }\n        if (control$verbose && !i %% n.batch)\n            setTxtProgressBar(pb, i)\n        # save results\n        if (i %in% resInd) {\n            jj <- match(i, resInd)\n            if (nbetas1) \n                res.betas1[jj, ] <- betas1\n            if (performHC) \n                res.betas2[jj, ] <- betas2            \n            if (hasScale)\n                res.tau[jj, ] <- tau\n            res.b[, , jj] <- b\n            if (performHC)\n                res.mean_b[, , jj] <- mean_b(indBetas)\n            res.invD[jj, ] <- c(invD)\n            if (notNullW)\n                res.gammas[jj, ] <- gammas\n            res.Bs.gammas[jj, ] <- if (rescale_Bs.gammas) {\n                tchol_CovBs.gammas %*% Bs.gammas + init.Bs.gammas\n            } else Bs.gammas\n            if (baseHazP)\n                res.tauBs[jj, ] <- tauBs\n            if (estimateAlphas)\n                res.alphas[jj, ] <- alphas\n            if (paramExtra)\n                res.Dalphas[jj, ] <- Dalphas\n            if (estimateWeightFun)\n                res.shapes[jj, ] <- shapes\n            log.pyb <- fastSumID2(densLong(y.long, eta.y, 1/sqrt(tau), log = TRUE, data), idFast)\n            log.h0s <- if (rescale_Bs.gammas) {\n                drop(W2s %*% (tchol_CovBs.gammas %*% Bs.gammas + init.Bs.gammas))\n            } else drop(W2s %*% Bs.gammas)\n            if (!paramRE) {\n                Mtime <- numeric(n)\n                Ms <- numeric(ns)\n                if (paramValue) {\n                    Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n                    Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n                }\n                if (paramExtra) {\n                    Mtime <- Mtime + if (is.matrix.ex) drop(ex %*% Dalphas) else ex * Dalphas\n                    Ms <- Ms + if (is.matrix.exs) drop(exs %*% Dalphas) else exs * Dalphas\n                }\n                if (estimateWeightFun) {\n                    wFun <- w * weightFun(u.idGK, shapes, max.time)\n                    wFun2 <- w2 * weightFun(u.idGK2, shapes, max.time)\n                    Zsb <- rowSums(Zs * b[id.GK, , drop = FALSE])\n                    Zub <- rowSums(Zu * b[id.GKu, , drop = FALSE])\n                    if (nbetas1) {\n                        Xsbetas <- drop(Xs %*% betas1)\n                        Xubetas <- drop(Xu %*% betas1)\n                        vl <- transFun.value(P * fastSumID2(wFun * (Xsbetas + Zsb), id.GKFast), data.id)\n                        vls <- transFun.value(P2 * fastSumID2(wFun2 * (Xubetas + Zub), id.GK2Fast), data.s)\n                    } else {\n                        vl <- transFun.value(P * fastSumID2(wFun * Zsb, id.GKFast), data.id)\n                        vls <- transFun.value(P2 * fastSumID2(wFun2 * Zub, id.GK2Fast), data.s)\n                    }\n                    Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n                    Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n                }                \n                if (notNullW) {\n                    if (LongFormat) {\n                        log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Wsgammas + Ms), id.GKFast)\n                    } else {\n                        Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n                        log.Surv <- expWgammas * Int\n                    }\n                } else {\n                    log.Surv <- Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n                }\n            } else {\n                log.Surv <- Int <- if (notNullW && LongFormat) {\n                    P * fastSumID2(w * exp(log.h0s + Wsgammas), id.GKFast)\n                } else {\n                    P * fastSumID2(w * exp(log.h0s), id.GKFast)\n                }\n                Mtime <- if (paramSharedRE) {\n                    mu_b <- if (performHC) mean_b(indBetas) else betas2\n                    drop((b - mu_b) %*% alphas) \n                } else {\n                    mu_b <- if (performHC) mean_b(indBetas) else betas2\n                    betas <- numeric(if (performHC) nbetas1 + nbetas2 else nbetas1)\n                    if (nbetas1) betas[!indBetasL] <- betas1\n                    if (performHC) betas[indBetasL] <- betas2\n                    bb_ <- (b - mu_b) + betas[indBetasRE]\n                    drop(bb_ %*% alphas)\n                }\n                log.Surv <- exp(Mtime) * log.Surv\n                if (notNullW && !LongFormat)\n                    log.Surv <- expWgammas * log.Surv\n            }\n            log.h <- if (rescale_Bs.gammas) {\n                drop(W2 %*% (tchol_CovBs.gammas %*% Bs.gammas + init.Bs.gammas)) + Mtime\n            } else drop(W2 %*% Bs.gammas) + Mtime\n            if (notNullW)\n                log.h <- drop(W %*% gammas) + log.h\n            log.ptb <- event * log.h - log.Surv\n            mu_b <- if (performHC) mean_b(indBetas) else betas2\n            log.pb <- densRE(b, mu = mu_b, invD = invD, log = TRUE, prop = FALSE)\n            res.logLik[jj, ] <- log.pyb + log.ptb + log.pb\n        }\n    })\n    if (control$verbose)\n        close(pb)\n    res.betas <- matrix(0, n.out, if (performHC) nbetas1 + nbetas2 else nbetas1)\n    if (nbetas1)\n        res.betas[, !indBetasL] <- res.betas1\n    if (performHC)\n        res.betas[, indBetasL] <- res.betas2\n    mcmcOut <- list(betas = res.betas, sigma = if (hasScale) 1/sqrt(res.tau), b = res.b,\n                    D = if (ncZ > 1) t(apply(res.invD, 1L, function (x) solve.default(matrix(x, ncZ))))\n                    else as.matrix(apply(res.invD, 1L, function (x) solve.default(matrix(x, ncZ)))),\n                    gammas = if (notNullW) res.gammas, Bs.gammas = res.Bs.gammas,\n                    tauBs = if (baseHazP) res.tauBs,\n                    alphas = if (estimateAlphas) res.alphas, Dalphas = if (paramExtra) res.Dalphas,\n                    shapes = if (estimateWeightFun) res.shapes)\n    mcmcOut <- mcmcOut[!sapply(mcmcOut, is.null)]\n    # calculate pD\n    D.bar <- - 2 * mean(rowSums(res.logLik, na.rm = TRUE), na.rm = TRUE)\n    postMeans <- lapply(mcmcOut, function (x) {\n        d <- dim(x)\n        if (!is.null(d) && length(d) > 2) apply(x, c(1L, 2L), mean) else colMeans(as.matrix(x))\n    })\n    dim(postMeans$D) <- c(ncZ, ncZ)\n    betas <- postMeans$betas; betas2 <- betas[indBetasL]; betas1 <- betas[!indBetasL]\n    if (!performHC) betas2 <- numeric(ncZ)\n    sigma <- postMeans$sigma; b <- postMeans$b; D <- postMeans$D\n    gammas <- postMeans$gammas; Bs.gammas <- postMeans$Bs.gammas; alphas <- postMeans$alphas\n    Dalphas <- postMeans$Dalphas; shapes <- postMeans$shapes\n    log.pyb <- fastSumID2(densLong(y.long, drop(X %*% betas1 + rowSums(Z * b[id, , drop = FALSE])),\n                                   sigma, log = TRUE, data), idFast)\n    log.h0s <- drop(W2s %*% Bs.gammas)\n    if (!paramRE) {\n        Mtime <- numeric(n)\n        Ms <- numeric(ns)\n        if (paramValue) {\n            if (nbetas1) {\n                vl <- transFun.value(drop(Xtime %*% betas1) + rowSums(Ztime * b), data.id)\n                vls <- transFun.value(drop(Xs %*% betas1) + rowSums(Zs * b[id.GK, , drop = FALSE]), data.s)\n            } else {\n                vl <- transFun.value(rowSums(Ztime * b), data.id)\n                vls <- transFun.value(rowSums(Zs * b[id.GK, , drop = FALSE]), data.s)                \n            }\n            Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n            Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n        }\n        if (paramExtra) {\n            if (nbetas1) {\n                ex <- transFun.extra(drop(Xtime.extra %*% betas1[iF]) +\n                                         rowSums(Ztime.extra * b[, iR, drop = FALSE]), data.id)\n                exs <- transFun.extra(drop(Xs.extra %*% betas1[iF]) +\n                                          rowSums(Zs.extra * b[id.GK, iR, drop = FALSE]), data.s)\n            } else {\n                ex <- transFun.extra(rowSums(Ztime.extra * b[, iR, drop = FALSE]), data.id)\n                exs <- transFun.extra(rowSums(Zs.extra * b[id.GK, iR, drop = FALSE]), data.s)\n            }\n            Mtime <- Mtime + if (is.matrix.ex) drop(ex %*% Dalphas) else ex * Dalphas\n            Ms <- Ms + if (is.matrix.exs) drop(exs %*% Dalphas) else exs * Dalphas\n        }\n        if (estimateWeightFun) {\n            wFun <- w * weightFun(u.idGK, shapes, max.time)\n            Zsb <- rowSums(Zs * b[id.GK, , drop = FALSE])\n            wFun2 <- w2 * weightFun(u.idGK2, shapes, max.time)\n            Zub <- rowSums(Zu * b[id.GKu, , drop = FALSE])\n            if (nbetas1) {\n                Xsbetas <- drop(Xs %*% betas1)\n                Xubetas <- drop(Xu %*% betas1)\n                vl <- transFun.value(P * fastSumID2(wFun * (Xsbetas + Zsb), id.GKFast), data.id)\n                vls <- transFun.value(P2 * fastSumID2(wFun2 * (Xubetas + Zub), id.GK2Fast), data.s)\n            } else {\n                vl <- transFun.value(P * fastSumID2(wFun * Zsb, id.GKFast), data.id)\n                vls <- transFun.value(P2 * fastSumID2(wFun2 * Zub, id.GK2Fast), data.s)                \n            }\n            Mtime <- Mtime + if (is.matrix.vl) drop(vl %*% alphas) else vl * alphas\n            Ms <- Ms + if (is.matrix.vls) drop(vls %*% alphas) else vls * alphas\n        }\n        if (notNullW) {\n            if (LongFormat) {\n                Wsgammas <- drop(Ws %*% gammas)\n                log.Surv <- P * fastSumID2(w * exp(log.h0s + Wsgammas + Ms), id.GKFast)\n            } else {\n                Int <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n                log.Surv <- exp(drop(W %*% gammas)) * Int\n            }\n        } else {\n            log.Surv <- P * fastSumID2(w * exp(log.h0s + Ms), id.GKFast)\n        }    \n    } else {\n        Mtime <- if (paramSharedRE) {\n            mu_b <- if (performHC) mean_b(indBetas) else betas2\n            drop((b - mu_b) %*% alphas) \n        } else {\n            mu_b <- if (performHC) mean_b(indBetas) else betas2\n            betas <- numeric(if (performHC) nbetas1 + nbetas2 else nbetas1)\n            if (nbetas1) betas[!indBetasL] <- betas1\n            if (performHC) betas[indBetasL] <- betas2\n            bb_ <- (b - mu_b) + betas[indBetasRE]\n            drop(bb_  %*% alphas)\n        }\n        if (notNullW) {\n            if (LongFormat) {\n                Wsgammas <- drop(Ws %*% gammas)\n                log.Surv <- P * fastSumID2(w * exp(log.h0s + Wsgammas), id.GKFast)\n            } else {\n                log.Surv <- exp(drop(W %*% gammas)) * P * fastSumID2(w * exp(log.h0s), id.GKFast)\n            }\n            \n        } else {\n            log.Surv <- P * fastSumID2(w * exp(log.h0s), id.GKFast)\n        }\n        log.Surv <- exp(Mtime) * log.Surv\n    }\n    log.h <- drop(W2 %*% Bs.gammas) + Mtime\n    if (notNullW)\n        log.h <- drop(W %*% gammas) + log.h\n    log.ptb <- event * log.h - log.Surv\n    mu_b <- if (performHC) mean_b(indBetas) else rep(0, ncZ)\n    log.pb <- densRE(b, mu = mu_b, D = D, log = TRUE, prop = FALSE)\n    D.hat <- - 2 * sum(log.pyb + log.ptb + log.pb, na.rm = TRUE)\n    pD <- D.bar - D.hat\n    indb <- names(mcmcOut) != \"b\"\n    postVarsRE <- apply(res.b, 1L, function (x) var(t(x)))\n    dim(postVarsRE)<- c(ncZ, ncZ, n)\n    keepD <- length(betas) + 1 + which(!lower.tri(invD, TRUE))\n    keepAR <- -seq_len(n.adapt)\n    postModes <- lapply(mcmcOut[indb], function (x) apply(as.matrix(x), 2L, modes))\n    dim(postModes$D) <- c(ncZ, ncZ)\n    if (performHC) {\n        mcmcOut$b <- res.b - res.mean_b\n        postMeans$b <- apply(mcmcOut$b, c(1L, 2L), mean)\n    }\n    list(mcmc = if (control$keepRE) mcmcOut else mcmcOut[indb], postMeans = postMeans,\n         postModes = postModes,\n         postVarsRE = postVarsRE,\n         StErr = lapply(mcmcOut[indb], stdErr),\n         EffectiveSize = lapply(mcmcOut[indb], effectiveSize),\n         StDev = lapply(mcmcOut[indb], function (x) apply(as.matrix(x), 2L, sd)),\n         CIs = lapply(mcmcOut[indb], function (x) \n             apply(as.matrix(x), 2L, quantile, probs = c(0.025, 0.975))),\n         Pvalues = lapply(mcmcOut[indb], function (x) apply(as.matrix(x), 2L, computeP)),\n         vcov = if (ncZ > 1L) var(do.call(cbind, mcmcOut[indb])[, -keepD]) else var(do.call(cbind, mcmcOut[indb])),\n         pD = pD, DIC = pD + D.bar, CPO = 1 / colMeans(exp(-res.logLik)),\n         LPML = sum(-log(colMeans(exp(-res.logLik))), na.rm = TRUE), time = time,\n         scales = list(betas = if (nbetas1) scale.betas1, b = scale.RE, \n                       Bs.gammas = scale.Bs.gammas,\n                       gammas = if (notNullW) scale.gammas,\n                       alphas = if (estimateAlphas) scale.alphas,\n                       Dalphas = if (paramExtra) scale.Dalphas),\n         Covs = Covs,\n         acceptRates = list(betas = mean(ar.betas[keepAR]), b = colMeans(ar.b[keepAR, ]),\n                            D = mean(ar.invD[keepAR]), \n                            Bs.gammas = mean(ar.Bs.gammas[keepAR]),\n                            gammas = if (notNullW) mean(ar.gammas[keepAR]),\n                            alphas = if (estimateAlphas) mean(ar.alphas[keepAR]),\n                            Dalphas = if (paramExtra) mean(ar.Dalphas[keepAR])))\n}\n",
    "created" : 1442396486933.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1503018924",
    "id" : "9E7409B8",
    "lastKnownWriteTime" : 1442839063,
    "path" : "C:/Users/Dimitris/Documents/PackagesGitHub/JMbayes/R/MCMCfit.R",
    "project_path" : "R/MCMCfit.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}